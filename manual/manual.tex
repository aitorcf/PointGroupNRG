\documentclass[notitlepage]{article}

\usepackage[T1]{fontenc}

\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{hyperref}

\usepackage{biblatex}
\addbibresource{manual.bib}

\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\bra}[1]{\langle #1 |}

\title{PointGroupNRG Manual}
\author{Aitor Calvo-Fernández, acalvo049@ehu.eus}

\begin{document}

\maketitle

\tableofcontents

\section{Overview}\label{overview}
This manual describes how to use the \texttt{PointGroupNRG}
code. Some context and theory are introduced at certain
points, but it does not serve as a comprehensive guide to
the NRG technique. For a comprehensive review of the NRG method, see
Ref. \cite{bulla2008}. For a description of the theory and
implementation specific to \texttt{PointGroupNRG}, see Refs.
\cite{calvo-fernandez2024} and [new arxiv], which also
contain useful references specific to the applications of
symmetry in the NRG.
\par
This manual starts in Section \ref{workflow} by describing
the typical steps in the preparation and execution of an NRG
calculation. Section \ref{clebsch-gordan} describes the
format for the Clebsch-Gordan coefficients that have to be
provided in order to use finite point or double group
symmetries. Sections \ref{multiplet_calculation} and
\ref{nrg} deal with the main functions provided
by the code and are organized by describing first the
required arguments and then the optional ones, introducing
the necessary information along the way. Section
\ref{multiplet_calculation} covers the
\texttt{compute\_multiplets} function of the
\texttt{PointGroupNRG.MultipletCalculator} submodule, which
constitutes the first step in the setup of a model. Section
\ref{nrg} gives information about the
\texttt{nrgfull} function of the
\texttt{PointGroupNRG.NRGCalculator} submodule, which
constructs the model and solves it using the NRG.
\par
The functions \texttt{compute\_multiplets} and
\texttt{nrgfull} as they are defined in their respective
submodules have more optional keyword arguments than those
described here. The arguments not described here
are in general related to features in development and
changing their value might cause the program to crash.

\section{Julia basics}
To make the manual self-contained, here we describe the
variable types required to use the code and how to construct
them, as well as a clarification of the input type notation
for functions. Usage examples can be found in the
\texttt{examples/} directory. Nonetheless, we encourage
using the official Julia documentation \cite{juliadoc}.
\par
The main functions in \texttt{PointGroupNRG} have typed
arguments, meaning that the variables given as input need to
be of the required type for the function to recognize them. 
Since it is not possible in Julia to define a variable to be
of a definite type in global scope as one would do inside a
function, \textit{e.g.} \texttt{n::Int64=1}, here we describe 
how to initialize variables to match the desired type.

\subsection{Simple variables}
\begin{itemize}
    \item \texttt{Int64}: Integer numbers with 64-bit
        precision. For example, 
\begin{verbatim}
    julia> n = 1; # semicolon disables printing
    julia> typeof(n) # get type of n
    Int64
\end{verbatim}
    \item \texttt{Float64}: Real floating point number with
        64-bit precision. For example, 
\begin{verbatim}
    julia> f = 1.0;
    julia> typeof(f)
    Float64
\end{verbatim}
    \item \texttt{ComplexF64}: Complex floating point number
        with 64-bit precision. For example,
\begin{verbatim}
    julia> c1 = 1.0 + 0.0im;
    julia> typeof(c1)
    ComplexF64
    julia> c2 = ComplexF64(1.0);
    julia> c1==c2 # check equality
    true
\end{verbatim}
    \item \texttt{String}: For example,
\begin{verbatim}
    julia> s = "PointGroupNRG";
    julia> typeof(s)
    String
\end{verbatim}
    \item \texttt{Function}: A function is a variable type
        in Julia just as any of the ones mentioned above.
        For example, $f=x->0.5$, $f(x)=0.5$ and 
\begin{verbatim}
    julia> function f(x)
               return 0.5
           end
    julia> f(2.5)
    0.5
    julia> f(true)
    0.5
    julia> g = x->0.5 # anonymous function syntax
    julia> g(0)==f(0) # equal return values
    true
\end{verbatim}
        Functions can have fixed argument types, each
        definition of the function with a different set of
        arguments (with their types) defining a distinct
        method:
\begin{verbatim}
    julia> f(x::Float64) = "hello"
    f (generic function with 1 method)
    julia> f(0.5)
    "hello"
    julia> f(n::Int64) = 1
    f (generic function with 2 methods)
    julia> f(2)
    1
    julia> f(true)
    ERROR: MethodError: no method matching f(::Bool)
    ...
\end{verbatim}
        The argument types can also be parametric:
\begin{verbatim}
    julia> g(x::SF) where {SF<:Union{String,Float64}} = SF
    g (generic function with 1 method)
    julia> g(1.0)
    Float64
    julia> g("hello")
    String
\end{verbatim}
        This syntax is used by the functions
        \texttt{compute\_multiplets}
        (\ref{multiplet_calculation}) and \texttt{nrgfull}
        (\ref{nrg_calculation}).
\end{itemize}

\subsection{Containers}
\begin{itemize}
    \item \texttt{Tuple\{T1,T2,...,Tn\}}: 
        Fixed-length immutable container with the type
        determined by the types of its contents. For example, 
\begin{verbatim}
    julia> t = (1,"a",1.0);
    julias> typeof(t) # get type of t
    Tuple{Int64,String,Float64}
\end{verbatim}
    \item \texttt{Array\{T,N\}}: \texttt{N}-dimensional array 
        containing elements of type \texttt{T}. For example, 
\begin{verbatim}
    julia> arr = zeros(ComplexF64,2,3,4);
    julia> typeof(arr)
    Array{ComplexF64,3}
    julia> size(arr) # array dimensions
    (2, 3, 4)
\end{verbatim}
        Its elements are accessed using the syntax
\begin{verbatim}
    julia> arr[2,3,1]
    0.0 + 0.0im
\end{verbatim}
    \item \texttt{Vector\{T\}}: 1-dimensional array containing
        elements of type \texttt{T}. For example,
\begin{verbatim}
    julia> v1 = [1.0, 2.0, 3.0];  # Float64 by default
    julia> v2 = Float64[1, 2, 3]; # Float64 conversion
    julia> v1==v2 # equal vectors
    true
\end{verbatim}
    \item \texttt{Matrix\{T\}}: 2-dimensional array containing
        elements of type \texttt{T}. For example,
\begin{verbatim}
    julia> m1 = [1.0+0.0im 0.0im; 0.0im 1.0+0.0im]
    2×2 Matrix{ComplexF64}:
     1  0
     0  1
    julia> m2 = ComplexF64[1 0; 0 1];
    julia> m1==m2
    true
    julia> m3 = [1.0;;] # 1x1 matrix syntax
    1×1 Matrix{Float64}:
     1.0
\end{verbatim}
    \item \texttt{Dict\{Tk,Tv\}}: Dictionary containing keys
        of type \texttt{Tk} pointing to values of type
        \texttt{Tv}. For example, 
\begin{verbatim}
    julia> d = Dict( "a" => [1.0] )
    Dict{String, Vector{Float64}} with 1 entry:
      "a" => [1.0]
\end{verbatim}
\end{itemize}

\section{Symmetry and irreducible representations}
\label{symmetry_and_irreducible_representations}
The code offers three symmetry types, one for each
symmetry-breaking situation and each with its own
irreducible representations:
\begin{itemize}
    \item Crystal field:
        \begin{equation}
            G_\text{UPS} = 
            U(1)_\text{C} \otimes
            P_\text{O} \otimes
            SU(2)_\text{S}
        \end{equation}
        is the combination of the unitary charge symmetry
        $U(1)_\text{C}$ leading to particle conservation, the
        orbital point group symmetry $P_\text{O}$, and the
        rotational symmetry in spin space $SU(2)_\text{S}$ leading
        to total spin conservation. The irreps are 
        \begin{equation}
            \Gamma_\text{UPS} = (N,I,S),
        \end{equation}
        where $N$ is the particle number, $I$ is the point
        group irrep, and $S$ is the total spin, and they are
        represented in the code with variables of the type
        \texttt{Tuple\{Int64,String,Float64\}}. For
        instance, \texttt{(2,"A1g",2.0)} represents the
        irrep of states with $N=2$ particles, orbital
        symmetry $I=A_{1g}$ and total spin $S=2$; this is
        the same representation that is going to be used for
        all symmetry groups: the \texttt{Int64} slot is used
        for the particle number, the \texttt{String} slot
        for the finite (point or double) group irrep, and
        the \texttt{Float64} for the total spin or total
        angular momentum.
    \item Spin-orbit coupling:
        \begin{equation}
            G_\text{UJ} =
            U(1)_\text{C} \otimes
            SU(2)_\text{OS}
        \end{equation}
        is the combination of the unitary charge symmetry
        $U(1)_\text{C}$ leading to particle conservation and
        the spin-orbital rotation group $SU(2)_\text{OS}$
        leading to the conservation of total angular
        momentum. The irreps are of the type
        \texttt{(2,"anything",3.5)}, which is the irrep of
        states with $N=2$ particles and total angular momentum
        $J=3.5$; \texttt{"anything"} in the \texttt{String} slot 
        just means that the slot is unused,
        so it can be filled with any \texttt{String} and the
        code will internally handle it as an identity irrep.
    \item Crystal field and spin-orbit coupling:
        \begin{equation}
            G_\text{UD} =
            U(1)_\text{C} \otimes
            D_\text{OS}
        \end{equation}
        is the combination of the unitary charge symmetry
        $U(1)_\text{C}$ leading to particle conservation and
        the spin-orbital double group $D_\text{OS}$. 
        The irreps are of the type \texttt{(2,"A1g",0.0)}, which 
        is the irrep of states with $N=2$ particles
        and belonging to the double group irrep $I=A_{1g}$;
        \texttt{0.0} is the identity irrep of angular
        momentum (spin $S$ or total angular momentum $J$),
        which serves to turn off the continuous rotation
        symmetry $SU(2)$.
\end{itemize}
When requiring irreps with particle numbers $N=1$ or $N=2$,
the code follows the following convention:
\begin{itemize}
    \item $N=1$: One-particle irreps are completely
        specified by one quantum number, which the code
        represents with the indicated type, depending of the
        symmetry of the model:
        \subitem  $G_\text{UPS}$: Point group irrep $I$. (The
        spin of the individual particles is always
        $S=\frac{1}{2}$.) Represented as a \texttt{String}.
        \subitem $G_\text{UJ}$: Total angular momentum $J$.
        Represented as \texttt{Float64}.
        \subitem $G_\text{UD}$: Double group irrep $I$.
        Represented as \texttt{String}.
    \item $N=2$ Two-particle irreps are specified by two
        quantum numbers, although depending on the symmetry
        only one is relevant. The variable type is always
        \texttt{Tuple\{String,Float64\}}, and it stores
        the information for the various symmetry types as
        follows: 
        \subitem $G_\text{UPS}$: Point group irrep $I$ and
        total spin $S$.
        \subitem $G_\text{UJ}$: Total angular momentum $J$.
        The provided $I$ quantum number will be substituted
        by the default finite group identity irrep
        \texttt{"A"}.
        \subitem $G_\text{UD}$: Double group irrep $I$. The
        provided $S$/$J$ quantum number will be substituted
        by $0.0$, the identity irrep of the rotation group.
\end{itemize}

\section{Workflow}\label{workflow}
The number of steps required for an NRG calculation varies
depending on the amount of setup information that is already
available. Here we describe all the necessary steps for a
full calculation starting from scratch for a model requiring
Clebsch-Gordan coefficients for a point or double group.
The workflow consists of three main steps:
\begin{enumerate}
    \item Prepare the directory containing the
        Clebsch-Gordan coefficients following the format
        specificed in Section \ref{clebsch-gordan}. These
        coefficients will then be read by the functions
        executed in the next steps. This step is not
        required for models with total angular momentum
        conservation, since the Clebsch-Gordan coefficients
        for the $SU(2)$ spin-orbital symmetry group are
        computed by the program.
    \item Compute the multiplet states for the electronic
        degrees of freedom of the conduction band and, if
        necessary, for the impurity (see Section
        \ref{nrg_calculation}). This is achieved with the
        \texttt{compute\_multiplets} function described in
        Section \ref{multiplet_calculation}, which
        calculates the multiplet states and stores them into
        an appropriate format. This step has to be performed
        only once for each irrep of the electronic degrees
        of freedom of a given model, so it is recommended to
        include it in an independent script separate from
        step 3.
    \item Construct the model and perform the NRG
        calculation using the \texttt{nrgfull} function
        described in Section \ref{nrg_calculation}.
        Calculations can be performed also for three
        intermediate stages giving partial results:
        two-particle multiplets, the impurity spectrum, and
        the impurity-shell spectrum (see \ref{nrg_until}).
\end{enumerate}

\section{Examples}
\label{examples}
Examples covering all the steps mentioned in \ref{workflow}
are provided in the directory \texttt{examples/}. The
examples are:
\begin{itemize}
    \item \texttt{krishnamurthy1980}: One-orbital,
        one-channel Anderson model. See Refs.
        \cite{krishna-murthy1980a} and
        \cite{krishna-murthy1980b}.
    \item \texttt{infinitecoulomb}: Ionic model of electrons
        with total angular momentum $J$ (to be fixed by the
        user) and infinite Coulomb repulsion, leaving only a
        one-particle multiplet and the empty multiplet. See
        \cite{hewson1997}, Ch. 1.9.
    \item \texttt{cubic-e}: Electrons belonging to a
        subspace belonging to irrep $E$, which can be viewed as
        resulting from the splitting of a $d$ level under a
        crystal field with cubic symmetry $O$. The standard
        and ionic Anderson models are used in the script. 
        See \cite{calvo-fernandez2024} for an equivalent
        $E_g$ model.
    \item \texttt{uranium378}: 3-7-8 model with a non-Fermi
        liquid ground state, proposed for an uranium
        impurity. See Ref. \cite{cox1987}.
\end{itemize}

\section{Clebsch-Gordan coefficients}\label{clebsch-gordan}
Calculations for models with point or double group
symmetries require the Clebsch-Gordan coefficients for the
group given in the following format: The coefficients are
organized according to the reduction of irrep products. If
\texttt{A} and \texttt{B} are the user-given names of two
irreps of the finite group $G$, then their decomposition is
\begin{equation}
    \texttt{A} \boxtimes \texttt{B}
    =
    \oplus_\texttt{C} \texttt{L(C)} \texttt{C},
\label{eq:A_times_B}
\end{equation}
where \texttt{C} are irreps of $G$ and \texttt{L(C)} is the
number of times \texttt{C} appears in the decomposition. On
top of the names, the irreps of $G$ must be arbitrarily
numbered by the user, starting from 0. If \texttt{A},
\texttt{B} and \texttt{C} are the \texttt{a}-th,
\texttt{b}-th and \texttt{c}-th irreps of $G$, respectively,
then the Clebsch-Gordan coefficients of the irrep
decomposition of \texttt{A}$\boxtimes$\texttt{B} must be
contained in a file called \texttt{axb\_AxB.txt}. That file
should be organized in paragraphs separated by blank lines,
each paragrah containing the Clebsch-Gordan coefficients
associated to the subspaces belonging to each irrep in the
following format:
\begin{verbatim}
    c C l
    ( 1 1 | 1 ) = <( A, 1 ; B, 1 | C, 1 )>
    ...
\end{verbatim}
where \texttt{l}$=1,\dots,$\texttt{L} labels the distinct
subspaces belonging to \texttt{C} that arise in the
decomposition of \texttt{A}$\boxtimes$\texttt{B},  and
\texttt{<( A, 1 ; B, 1 | C, 1 )>} is meant to be substituted by
the value of the Clebsch-Gordan coefficient given in any
format that Julia can parse into a complex number. The dots
\texttt{...} have to be filled with the rest of the
Clebsch-Gordan coefficients following the same format,
\begin{verbatim}
    ( gA gB | gC ) = <( A, gA ; B, gB | C, gC )
\end{verbatim}
where \texttt{gA}, \texttt{gB} and \texttt{gC} are the
partner numbers of the irreps \texttt{A}, \texttt{B} and
\texttt{C}, respectively. Only the non-zero coefficients are
necessary. To compare this with the notation in Refs.
\cite{calvo-fernandez2024} and [new arxiv], substitute the
irreps (partners) following the rule
$\Gamma_A\leftrightarrow$\texttt{A}
($\gamma_A\leftrightarrow$\texttt{gA}),
$\Gamma_B\leftrightarrow$\texttt{B}
($\gamma_B\leftrightarrow$\texttt{gB}) and
$\Gamma_C\leftrightarrow$\texttt{C}
($\gamma_C\leftrightarrow$\texttt{gC}). The files for all
the irrep combinations \texttt{A}$\boxtimes$\texttt{B} with
\texttt{a}$\geq$\texttt{b} (to avoid redundancy) must be
stored into a directory. An example of Clebsch-Gordan
coefficients can be found in
\texttt{examples/clebschgordan/O}, which contains the
Clebsch-Gordan coefficients for the cubic group $O$ in the
appropriate format.

\section{Multiplet calculation: \texttt{compute\_multiplets}}
\label{multiplet_calculation}
The function \texttt{compute\_multiplets} computes the
many-body multiplet states arising from the combination of
electrons in states belonging to the same one-electron
irrep. If the impurity and conduction electrons occupy
states belonging to irreps $\Gamma_1$ and $\Gamma_2$, for
instance, then \texttt{compute\_multiplets} has to be run
once for $\Gamma_1$ and once for $\Gamma_2$. This is also
the case if there are several multiplet subspaces belonging
to $\Gamma_1$, for example, because the resulting states are
distinguished only by an outer multiplicity label that is
taken care of by \texttt{nrgfull} (see Section \ref{nrg}).
\par
The function stores the multiplet states for the irrep
\texttt{G} in
\begin{verbatim}
    $(multiplets_path)/$(G)/N$(N).txt
\end{verbatim}
\texttt{N} is the number of particles and \texttt{G} and
\texttt{multiplets\_path} are described in
\ref{multiplets_irrep} and \ref{multiplets_multipletspath},
respectively. These files are intended to be read by
\texttt{nrgfull} (\ref{nrg}). The
\texttt{compute\_multiplets} function also generates files 
\begin{verbatim}
    $(multiplets_path)/$(G)/N$(N)basis.txt
\end{verbatim}
containig the basis states expressed as a sequence of
\texttt{N} partner numbers for the finite (point or double)
group and another sequence for the $SU(2)$ group; if only
one group type is used, the numbers of the unused group are
substituted by \texttt{-}. 
\par
The function is defined as
\begin{verbatim}
    function compute_multiplets( 
        symmetry::String ;
        irrep::SF="" ,
        multiplets_path::String="multiplets" ,
        clebschgordan_path::String=""
    ) where {SF<:Union{String,Float64}}
\end{verbatim}
\subsection{Necessary arguments}

\subsubsection{\texttt{symmetry::String}}
\label{multiplets_symmetry}
Determines the type of symmetry. The accepted values are:
\begin{itemize}
    \item \texttt{"pointspin"} or \texttt{"PS"}: Uses
        the symmetry type
        \begin{equation}
            G_\text{UPS} = 
            U(1)_\text{C} \otimes
            P_\text{O} \otimes
            SU(2)_\text{S},
        \end{equation}
        which is the outer direct product of unitary charge
        symmetry $U(1)_\text{C}$ (particle conservation),
        the orbital point group $P_\text{O}$, and spin
        rotation symmetry $SU(2)_\text{S}$ (conservation of
        total spin).
    \item \texttt{"doublegroup"} or \texttt{"D"}: Uses 
        the symmetry type
        \begin{equation}
            G_\text{UOS} =
            U(1)_\text{C} \otimes
            D_\text{OS},
        \end{equation}
        which is the outer direct product of unitary charge
        symmetry $U(1)_\text{C}$ (particle conservation) and
        the spin-orbital double group $D_\text{OS}$.
    \item \texttt{"totalangularmomentum"}, \texttt{"J"},
        \texttt{"spin"} or \texttt{"S"}:
        Uses the symmetry type
        \begin{equation}
            G_\text{UJ} =
            U(1)_\text{C} \otimes
            SU(2)_\text{OS},
        \end{equation}
        which is the outer direct product of unitary charge
        symmetry $U(1)_\text{C}$ (particle conservation) and
        spin-orbital rotational invariance (conservation of
        total angular momentum).
\end{itemize}

\subsection{Optional keyword arguments}

\subsubsection{\texttt{irrep::SF=""}}
\label{multiplets_irrep}
One-electron irrep for which to compute the multiplet
states. The specification of the irrep changes depending on
the value of \texttt{symmetry} (\ref{multiplets_symmetry})
according to \ref{symmetry_and_irreducible_representations}:
\begin{itemize}
    \item If the value of \texttt{symmetry} corresponds to
        $G_\text{UOS}$, then \texttt{irrep} must be a
        \texttt{String} and is the name of the name of the
        point group irrep as it appears in the
        Clebsch-Gordan coefficient files (see
        \ref{clebsch-gordan}).
    \item If the value of \texttt{symmetry} corresponds to
        $G_\text{UD}$, then \texttt{irrep} must be a
        \texttt{String} and is the name of the name of the
        double group irrep as it appears in the
        Clebsch-Gordan coefficient files (see
        \ref{clebsch-gordan}).
    \item If the value of \texttt{symmetry} corresponds to
        $G_\text{UJ}$, then \texttt{irrep} must be a
        \texttt{Float} and is the value of the total spin
        $S$ or total angular momentum $J$ of the electrons,
        where $\mathbf J=\mathbf L + \mathbf S$.
\end{itemize}

\subsubsection{\texttt{clebschgordan\_path::String=""}}
\label{multiplets_clebschgordan}
Absolute or relative path of the directory where the
Clebsch-Gordan coefficients are stored (see
\ref{clebsch-gordan}). It must be provided only if
\texttt{symmetry} (\ref{multiplets_symmetry}) corresponds to
$G_\text{UOS}$ or $G_\text{UD}$, as the Clebsch-Gordan
coefficients of the rotation symmetry $SU(2)$ are computed
by the program.

\subsubsection{\texttt{multiplets\_path::String="multiplets"}}
\label{multiplets_multipletspath}
Absolute or relative path of the parent directory where the
directories containing the multiplet states for the chosen
irreps (see \ref{multiplets_irrep}) will be stored. It must
be the same for irreps intented to be used in the same NRG
calculation. If it does not already exist, it is
automatically created.

\section{NRG calculation: \texttt{nrgfull}}\label{nrg}
The \texttt{nrgfull} function constructs the model from the
input and the multiplet states computed by
\texttt{compute\_multiplets} (see
\ref{multiplet_calculation}), and it solves it using the NRG
method. It can be used to calculate thermodynamic functions
(see \ref{nrg_calculation}), spectral functions (see
\ref{nrg_spectral}), and/or impurity projections (see
\ref{nrg_computeimpurityprojections}). The function
definition is the following (dots \texttt{...} in the
right-hans side of keyword arguments represent the same
types as in the left-hand side):
\begin{verbatim}
    function nrgfull(
        symmetry::String ,
        label::String ,
        L::Float64 ,
        iterations::Int64 ,
        cutoff::IF ,
        shell_config::Dict{SF,Int64} ,
        tunneling::Dict{SF,Matrix{ComplexF64}} ;
        multiplets_path::String="multiplets" ,
        calculation::String="IMP" ,
        impurity_config::Dict{SF,Int64}=Dict{...}() ,
        onsite::Dict{SF,Vector{ComplexF64}}=Dict{...}() ,
        interaction::{Tuple{String,Float64},Matrix{ComplexF64}}=Dict{...}() ,
        spectrum::Dict{ClearIrrep,Vector{Float64}}=Dict{...}() ,
        lehmann_iaj::Dict{ClearTripleG,Array{ComplexF64,4}}=Dict{...}() ,
        until::String="",
        clebschgordan_path::String="" ,
        identityrep::String="" ,
        z::Float64=0.0 ,
        max_SJ2::Int64=10 ,
        channels_dos::Dict{SF,Vector{Function}}=Dict{...}() ,
        minimum_eigenenergy::Float64=0.0 ,
        betabar::Float64=1.0 ,
        spectral::Bool=false ,
        broadening_distribution::String="loggaussian" ,
        spectral_broadening::Float64=0.5 ,
        K_factor::Float64=2.0 ,
        compute_impurity_projections::Bool=false ,
        half_band_width::Float64=1.0 ,
        print_spectrum_levels::Int64=0 ,
    ) where {SF<:Union{String,Float64},IF<:Union{Int64,Float64}}
\end{verbatim}

\subsection{Necessary arguments}
\subsubsection{\texttt{symmetry::String}}
\label{nrg_symmetry}
See \ref{multiplets_symmetry}.

\subsubsection{\texttt{label::String}}
\label{nrg_label}
Label/name given to the system. It will appear in the
names of the output files: thermodynamic functions, spectral
functions and impurity projections. Output files are
ovewritten by subsequent calculations with the same value of
\texttt{label}.

\subsubsection{\texttt{L::Float64}}
\label{nrg_L}
Discretization parameter $\Lambda$. See Ref.
\cite{bulla2008}. Lower values result in a model closer to
the continuum limit $\Lambda\rightarrow 1$ but require
larger cutoffs, larger values result in convergence for
lower cutoffs (see \ref{nrg_cutoff}). Large values of
$\Lambda$ usually produce low resolution thermodynamic and
spectral functions and can result in artifacts such as
spurious oscillations. Oscillations can be removed in many
cases by averaging over even and odd step results, which is
done automatically, resulting in improved spectral functions
(\ref{nrg_spectral}) and often completely satisfactory
thermodynamic functions (\ref{nrg_calculation}. It is
possible to go further by averaging over various
discretizations (see \ref{nrg_z}). In general, it is
recommended to use low values $\Lambda\in[2,3]$ for the
spectral functions, while for thermodynamic functions values
as large as $\Lambda=10$ often give satisfactory results.

\subsubsection{\texttt{iterations::Int64}}
\label{nrg_iterations}
Number of iterations in the NRG calculation. Lower
temperatures (for thermodynamic function calculations) and
lower energies (for spectral function calculations) are
reached with more iterations.

\subsubsection{\texttt{cutoff:IF}}
\label{nrg_cutoff}
Cutoff imposed on the multiplets: after each iterations,
multiplets above the cutoff are discarded. The type of
cutoff varies depending on the type of the input
\texttt{cutoff}:
\begin{itemize}
    \item If \texttt{cutoff} is an \texttt{Int64},
    \textit{e.g.} \texttt{300}, then it
    specifies the number of multiplets kept at each
    iteration.
    \item If \texttt{cutoff} is a \texttt{Float64},
    \textit{e.g.} \texttt{7.0}, then it
    specifies the cutoff energy: multiplets with energies
    larger than that are discarded.
\end{itemize}
In both cases, the program tries to avoid breaking
accidental degeneracies by checking for a small energy
window above the imposed cutoff and keeping also the states
within that window.

\subsubsection{\texttt{shell\_config::Dict\{SF,Int64\}}}
\label{nrg_shellconfig}
It specifies the configuration of the conduction channels.
It has the structure
\begin{verbatim}
    Dict( 
        G1 => n1,
        G2 => n2,
        ...
    )
\end{verbatim}
where \texttt{G1}, \texttt{G2} , etc. are the irreps in the
one-electron irep format described in \ref{multiplets_irrep}
and \texttt{n1}, \texttt{n2}, etc. are the number of
channels with the symmetry belonging to the corresponding
irrep). The multiplet states for each irrep \texttt{Gi} must
have been calculated previously with
\texttt{compute\_multiplets} (\ref{multiplet_calculation}).

\subsubsection{\texttt{tunneling::Dict\{SF,Matrix\{ComplexF64\}\}}}
\label{nrg_tunnneling}
It specifies the tunneling amplitudes $V(\Gamma_a)_{r_a
r_b}$ as a dictionary with the format
\begin{verbatim}
    Dict(
        G1 => amplitudes1,
        G2 => amplitudes2,
        ...
    )
\end{verbatim}
where \texttt{G1}, \texttt{G2}, etc. are the irreps
$\Gamma_a$ in the format described in \ref{multiplets_irrep}
and \texttt{amplitudes1}, \texttt{amplitudes2}, etc. are the
amplitudes given as a \texttt{Matrix{ComplexF64}} with
indices $r_a,r_b$.
\par
In order to couple more than one channel to an orbital,
non-zero amplitudes have to be given for $r_a,r_b$
combinations with the same $r_a$ and different $r_b$. For
instance, to 
\begin{verbatim}
    impurity_config = Dict( "A" => 1 )
    shell_config = Dict( "A" => 2 )
    tunneling = Dict(
        "A" = ComplexF64[
            1.0 1.0
        ]
    )
\end{verbatim}


\subsection{Optional keyword arguments}

\subsubsection{\texttt{multiplets\_path::String="multiplets"}}
\label{nrg_multipletspath}
Same as \ref{multiplets_multipletspath}.

\subsubsection{\texttt{calculation::String="IMP"}}
\label{nrg_calculation}
The value of this variable sets whether the impurity is
included in the calculation or not, and is relevant in
particular for the calculation of thermodynamic functions,
which is performed automatically in every case. These are
the possible values:
\begin{itemize}
    \item \texttt{calculation="IMP"}: the impurity is
    included in the calculation, which is necessary for
    spectral function calculations (\ref{nrg_spectral}) and
    impurity projection
    (\ref{nrg_computeimpurityprojections}) calculations. The
    thermodynamic functions for the model are stored in the
    directory \texttt{thermodata/}, which is created
    automatically if it does not previously exist, and are
    distinguished by containing \texttt{imp} in their names.
    For instance, if \texttt{label=="X"} (\ref{nrg_label})
    and \texttt{z=="0.0"} (\ref{nrg_z}), the file would be
\begin{verbatim}
    thermodata/thermo_X_imp_z0.0.dat
\end{verbatim}
    If a \texttt{calculation="CLEAN"} run has been performed
    (see below), the impurity contribution to the
    thermodynamic functions is automatically computed by
    subtracting the \texttt{"CLEAN"} results from the
    \texttt{"IMP"} results (see Ref. \cite{bulla2008} for
    more details), and the resulting functions are stored in
    \texttt{thermodata} and distinguished by containing
    \texttt{diff} in their names. Following the previous
    example, the impurity contribution file would be
\begin{verbatim}
    thermodata/thermo_X_diff_z0.0.dat
\end{verbatim}
    \item \texttt{calculation="CLEAN"}: the impurity is
    excluded for the calculation, leaving only the
    conduction channels in the model. The resulting
    thermodynamic functions are stored in
    \texttt{thermodata} and distinguished by containing
    \texttt{clean} in their names. For the same example, the
    file would be
\begin{verbatim}
    thermodata/thermo_X_clean_z0.0.dat
\end{verbatim}
    This is typically only
    used for calculating the impurity contribution to the
    thermodynamic functions. 

\end{itemize}

\subsubsection{\texttt{impurity\_config::Dict\{SF,Int64\}}}
\label{nrg_impurityconfig}
It defines the degrees of freedom of the impurity for the
standard Anderson model (not the ionic model) defined in
terms of the on-site energies (\ref{nrg_onsite}) and the
interaction term (\ref{nrg_interaction}). The program
assumes that one model or the other is intended based on the
value of \texttt{spectrum} (\ref{nrg_spectrum}) and it
checks whether the rest of the necessary variables for that
model are provided. \texttt{impurity\_config} follows the
same format as \ref{nrg_shellconfig} and it also requires
the previous calculation of the multiplet states using
\texttt{compute\_multiplets} (\ref{multiplet_calculation}).

\subsubsection{\texttt{onsite::Dict\{SF,Vector\{ComplexF64\}\}=Dict\{...\}\}()}}
\label{nrg_onsite}
On-site energy term 
\begin{equation}
    \sum_a
    \epsilon(\Gamma_a)_{r_a}
    c^\dagger_a c_a
\end{equation}
given in the format
\begin{verbatim}
    Dict(
        G1 => energies1,
        G2 => energies2
        ...
    )
\end{verbatim}
where \texttt{G1}, \texttt{G2}, etc. are the irreps
$\Gamma_a$ given in the same format as
\ref{multiplets_irrep}, and \texttt{energies1},
\texttt{energies2}, etc. are \texttt{Vector}s with index
$r_a$ containing the eigenenergies corresponding to the
multiplets $m_a=(\Gamma_a,r_a)$. For more information, see
Refs. \cite{calvo-fernandez2024} and [new arxiv].

\subsubsection{\texttt{interaction::Dict\{Tuple\{String,Float64\},Matrix\{ComplexF64\}\}=Dict\{...\}()}}
\label{nrg_interaction}
Parameters of the interaction term
\begin{equation}
    \sum_{a,b,c,d} U_{abcd} 
    c^\dagger_a c^\dagger_b
    c_c c_d
\end{equation}
defined by the set of parameters $U(\Gamma_u)_{r_u r_v}$
from which the rest are constructed following the procedure
described in Ref. \cite{calvo-fernandez2024}. The argument
\texttt{interaction} contains the parameters $U(\Gamma_u)_{r_u r_v}$
in the format
\begin{verbatim}
    Dict(
        G1 => matrix_elements1,
        G2 => matrix_elements2
        ...
    )
\end{verbatim}
where \texttt{G1}, \texttt{G2}, etc. are the two-particle
irreps $\Gamma_u$, and
\texttt{matrix\_elements1}, \texttt{matrix\_elements2}, etc. are the matrix elements
$U(\Gamma_u)_{r_u r_v}$ for the corresponding irreps with
$r_u,r_v$ as indices. The irreps \texttt{Gu} are given as 
\texttt{Tuple\{String,Float64\}}s following the irrep format
described in \ref{symmetry_and_irreducible_representations}

\subsubsection{\texttt{spectrum::Dict\{Tuple\{Int64,String,Float64\},Vector\{Float64\}\}=Dict\{...\}()}}
\label{nrg_spectrum}
It is the spectrum of the impurity in the ionic model, which
defines the impurity term in the Hamiltonian (see [new
arxiv])
\begin{equation}
    H_\text{imp}
    =
    \sum_i
    \epsilon(\Gamma_i)_{r_i}
    \ket{i}\bra{i}.
\end{equation}
The spectrum is provided in the format
\begin{verbatim}
    Dict(
        G1 => energies1,
        G2 => energies2,
        ...
    )
\end{verbatim}
where \texttt{G1}, \texttt{G2}, etc. are the many-body irrep 
of type \texttt{Tuple\{Int64,String,Float64\}} as rescribed
in \ref{symmetry_and_irreducible_representations}, and
\texttt{energies1}, \texttt{energies2}, etc. are the
energies of the multiplets $m_i=(\Gamma_i,r_i)$ belonging to
the corresponding irrep $\Gamma_i$ provided as
\texttt{Vector}s with index $r_i$.

\subsubsection{\texttt{lehmann\_iaj::Dict\{G3,Array\{ComplexF64,4\}\}=Dict\{...\}()}}
\label{nrg_lehmanniaj}
Reduced Lehmann amplitudes (matrix elements of the creation
operator), used in the ionic model.
\begin{equation}
    \bra{\Gamma_i,r_i}| 
    f^\dagger_{\Gamma_a,r_a}
    |\ket{\Gamma_j,r_j}_\alpha
\end{equation}
Here \texttt{G3} means
\texttt{NTuple\{3,Tuple\{Int64,String,Float64\}\}}. The
format of \texttt{spectrum} is
\begin{verbatim}
    Dict(
        (G_i,G_a,G_j)_1 => amplitudes_1
        (G_i,G_a,G_j)_2 => amplitudes_2
        ...
    )
\end{verbatim}
where the irrep tuples \texttt{(G\_i,G\_a,G\_j)\_1},
\texttt{(G\_i,G\_a,G\_j)\_2}, etc. represent
$(\Gamma_i,\Gamma_a,\Gamma_j)$, and \texttt{amplitudes\_1},
\texttt{amplitudes\_2}, etc. are
\texttt{Array\{ComplexF64,4\}}s with indices
$\alpha,r_i,r_a,r_j$ containing the amplitudes for the
irreps specified in the key.

\subsubsection{\texttt{until::String=""}}
\label{nrg_until}
Setting \texttt{until} to a value different from the default
\texttt{until=""} causes \texttt{nrgfull} to stop at an
early stage of the calculation:
\begin{itemize}
    \item \texttt{until="2-particle multplets"}:
        \texttt{nrgfull} runs until it computes the impurity
        part of the Hamiltonian, after which it prints out
        information about the 2-particle multiplet states
        and then stops. This is particularly useful in order
        to know the symmetry-adapted parameters determining
        the Coulomb interaction that make up the input
        variable \texttt{interaction}
        (\ref{nrg_interaction}, see Ref.
        \cite{calvo-fernandez2024})
    \item \texttt{until="impurity spectrum"}:
        \texttt{nrgfull} runs until it computes the impurity
        spectrum, after which it prints it out and then
        stops. This is useful for checking the spectrum
        resulting from a given choice of symmetry-adapted
        Hamiltonian parameters \texttt{onsite}
        (\ref{nrg_onsite}) and \texttt{interaction}
        (\ref{nrg_interaction}.
    \item \texttt{until="impurity-shell spectrum"}:
        \texttt{nrgfull} runs until it computes the spectrum
        of the impurity plus the innermost conduction shell,
        after which it prints it out and then stops. This is
        useful for checking the spectrum resulting from the
        impurity spectrum plus the coupling to the
        conduction band via tunnneling.
\end{itemize}

\subsubsection{\texttt{clebschgordan\_path::String=""}}
Same as \ref{multiplets_clebschgordan}.

\subsubsection{\texttt{identityrep::String=""}}
\label{nrg_identityrep}
Identity irrep of the point group or the double group as it
appears in the Clebsch-Gordan coefficients given in the
directory \texttt{clebschgordan\_path} (see
\ref{multiplets_clebschgordan}). It is not necessary if for
the $G_\text{UJ}$ symmetry (see \ref{nrg_symmetry}).

\subsubsection{\texttt{z::Float64::String=""}}
\label{nrg_z}
Twisting parameter $z$ used for the interleaved
discretization scheme following the procedure described in
Ref. \cite{campo2005}. Results from calculations with
different $z$ values, both thermodynamic and spectral
functions, can be averaged to improve smoothness and remove
spurious oscillations arising for large values of $\Lambda$
(\texttt{L}, \ref{nrg_L}). The spurious oscillations are
already removed to a great extent by averaging over even and
odd calculations, which is done automatically
(\ref{nrg_calculation} and \ref{nrg_spectral}). Averaging
over various $z$ further improves it and allows for an
effectively more dense grid of energy values, which can be
especially useful for better spectral functions.
\par
The first step in a $z$-averaged calculations is to call
\texttt{nrgfull} for all the desired values of $z$. We can
do so using the function \texttt{generate\_Z} to generate
the values of $z$ and then iterating over them, each time
calling \texttt{nrgfull} for a different \texttt{z} value. 
Then we call the \texttt{zavg\_thermo} or
\texttt{zavg\_spectral} functions to compute the average
thermodynamic or spectral functions, respectively. For
instance, we could do
\begin{verbatim}
    # normal input
    ...

    Z = generate_Z(4)
    for z in Z
        for calculation in ["CLEAN","IMP"]
            nrgfull(
                ...;
                calculation=calculation,
                z=z
                ...
            )
        end
        zavg_thermo(label, Z)
    end
\end{verbatim}
for computing $z$-averaged thermodynamic functions, or
\begin{verbatim}
    # normal input
    ...
    Nz = 4
    Z = generate_Z(Nz)
    for z in Z
        nrgfull(
            ...;
            spectral=true,
            z=z
            ...
        )
        end
        zavg_spectral(label, Z; orbitalresolved_number=2)
    end
\end{verbatim}
where the \texttt{orbitalresolved\_number} variable tells
\texttt{zavg\_spectral} how many tunneling electron
multiplets are there, and therefore which spectral files
have to be taken into account when averaging
(\ref{nrg_spectral}). 
\par
One of the main advantages of $z$-averaged calculations is
that they can are completely independent from one another
and can therefore be performed in parallel. This is very
simple in Julia, and it can be done as
\begin{verbatim}
    using Distributed
    Nz = 4
    Z = generate_Z(Nz)
    addprocs(Nz)
    @everywhere begin
        # define input in all the processors here
        label=$label
        ...
    end
    @sync @distributed for z in Z
        nrgfull(
            ...;
            z=z,
        )
    end
\end{verbatim}
An example of a distributed $z$-averaged calculation is
provided in \texttt{examples/uranium378} (\ref{examples}).

\subsubsection{\texttt{max\_SJ2::Int64=10}}
\label{nrg_maxsj2}
Maximum value of twice the total spin $2S$ (for
$G_\text{PS}$ or $G_\text{UJ}$) or twice the total angular
momentum $2J$ (for $G_\text{UJ}$) that is expected to appear in
the NRG calculations (see \ref{nrg_symmetry}). This is used
for computing sums over Clebsch-Gordan coefficients, which
is done at the beginning of the calculation. If a value of
$2S$ or $2J$ larger than \texttt{max\_SJ2} if found, the
program will give an error.

\subsubsection{\texttt{channels\_dos::Dict\{SF,Vector{Function}\}=Dict\{SF,Vector{Function}\}()}}
\label{nrg_channelsdos}
Density of state (DOS) functions $\rho(\Gamma_b;\epsilon)_{r_b}$ of the
conduction electron channel multiplet $(\Gamma_b,r_b)$. In
the code, the density of states is defined as (i) carrying the
energy-dependence of the hybridization,
\begin{equation}
    \Delta(\Gamma_b;\epsilon)_{r_b}
    :=
    \pi
    \rho(\Gamma_b;\epsilon)_{r_b}
    V(\Gamma_b)_{r_b r_b}^2
\end{equation}
and (ii) normalized as
\begin{equation}
    \int_{-D}^D d\epsilon \rho(\Gamma_b;\epsilon)_{r_b} = 1,
    \label{eq:dos_normalization}
\end{equation}
where $D$ is the half band-width.
\par
For instance,
\begin{verbatim}
    channels_dos_1 = Dict(
        "E" => [x->0.5]
    )
    channels_dos_2 = Dict(
        "E" => [x->1.0]
    )
\end{verbatim}
define two equal constant DOS functions because the code
automatically normalizes the density of states functions
according to Eq. \ref{eq:dos_normalization}. The
discretization is performed for general DOS functions
following the procedure described in Ref. \cite{chen1995}.


\subsubsection{\texttt{minimum\_eigenenergy::Float64=0.0}}
\label{nrg_minimumeigenenergy}
If the largest eigenergy remaining after applying the
multiplet cutoff according to \ref{nrg_cutoff} is lower than
\texttt{minimum\_eigenenergy}, the number of multiplets kept
is increased until reaching the eigenenergy
\texttt{minimum\_eigenenergy}.

\subsubsection{\texttt{betabar::Float64=1.0}}
\label{nrg_betabar}
Parameter $\bar\beta$ used in thermodynamic calculations.
When calculating thermodynamic functions, the Boltzmann
factors $\exp(-\beta E_N)$, where $\beta=(k_B T)^-1$ and
$E_N$ is an eigenenergy in the $N$-th NRG step, are
substituted by $\exp(-\bar\beta \bar E _N)$, where
\begin{equation}
    \bar\beta=\omega_N \beta=\frac{\omega_N}{k_B T}
\end{equation}
is a constant that fixes the ratio between the energy scale
$\omega_N$ of each iteration and the temperature $T$,
thereby defining the temperature scale 
\begin{equation}
    T_N = \frac{\omega_N}{k_B \bar\beta}
\end{equation}
associated to each iteration $N$. For more detailed
information, see Ref. \cite{bulla2008}.

\subsubsection{\texttt{spectral::Bool=false}}
\label{nrg_spectral}
If \texttt{spectral==true} and \texttt{calculation=="IMP"}
(\ref{nrg_calculation}), \texttt{nrgfull} computes the
zero-temperature orbital-resolved spectral functions
\begin{equation}
    A_{\Gamma_a,r_a}(\omega) 
    = 
    \sum_g 
    |\bra{e} 
    f^\dagger_{\Gamma_a,r_a}
    \ket{g}|^2
    \delta(\epsilon-(\epsilon_e-\epsilon_g))
\label{eq:spectral_function}
\end{equation}
which it then stores
in files
\begin{verbatim}
    spectral/spectral\_<label>\_z<z>\_o<o>.dat
\end{verbatim}
where \texttt{<label>} is the value of \texttt{label}
(\ref{nrg_label}), \texttt{<z>} is the value of \texttt{z}
\ref{nrg_z}, and \texttt{<o>} is a number assigned by the
code to each orbital multiplet $\Gamma_a,r_a$. Which orbital
multiplet corresponds to each number is indicated in the
file header. The spectral function contained in the file is
obtained by averaging the spectral functions for the even
and odd iterations [REF]; information about the latter is
stored in the files
\begin{verbatim}
    spectral/spectral\_<label>\_z<z>\_o<o>_even.dat
    spectral/spectral\_<label>\_z<z>\_o<o>_odd.dat
\end{verbatim}


\subsubsection{\texttt{broadening\_distribution::String="loggaussian"}}
\label{nrg_broadeningdistribution}
Broadening kernel used to obtain continuous spectral
functions from the set of delta peaks calculated using Eq.
\ref{eq:spectral_function}. Three options are available:
\begin{itemize}
    \item \texttt{broadening\_distribution="loggaussian"}:
        \begin{equation}
            \delta(\epsilon-(\epsilon_e-\epsilon_g))
            \rightarrow
            \frac{1}{\eta \sqrt{\pi} |\epsilon_e-\epsilon_g|}
            \exp \left(
                \frac{\log^2
                |\frac{\epsilon}{\epsilon_e-\epsilon_g}|}{\eta^2}-
                \frac{\eta^2}{4}
            \right)
        \end{equation}
    \item \texttt{broadening\_distribution="gaussian"}:
        \begin{equation}
            \delta(\epsilon-(\epsilon_e-\epsilon_g))
            \rightarrow
            \frac{1}{\sqrt{\pi}\eta}
            \exp\left[
                -\left(
                    \frac{
                        \epsilon-(\epsilon_e-\epsilon_g)
                    }{
                        \eta
                    }
                \right)^2
            \right]
        \end{equation}
    \item \texttt{broadening\_distribution="lorentzian"}:
        \begin{equation}
            \delta(\epsilon-(\epsilon_e-\epsilon_g))
            \rightarrow
            \frac{1}{2\pi}
            \frac{
                \eta
            }{
                (\epsilon-(\epsilon_e-\epsilon_g))^2
                +\eta^2
            }
        \end{equation}
\end{itemize}
In all cases, $\eta$ is the broadening fractor fixed by the
argument \texttt{spectral\_broadening}
(\ref{nrg_spectralbroadening}).

\subsubsection{\texttt{spectral\_broadening::Float64=0.5}}
\label{nrg_spectralbroadening}
Broadening factor $\eta$ to be used in the broadening kernel
(see \ref{nrg_broadeningdistribution}).

\subsubsection{\texttt{K\_factor::Float64=2.0}}
\label{nrg_Kfactor}
When calculating the spectral functions
$A_{\Gamma_a,r_a}(\omega)$ (see Eq.
\ref{eq:spectral_function}), each NRG step is used to obtain
the value $A_{\Gamma_a,r_a}(\omega)$ at an energy
$K\omega_N$, where $\omega_N$ is the energy scale of the
$N$-th step and $K$ is the quantity fixed by
\texttt{K\_factor} (see Ref. \cite{bulla2008}).

\subsubsection{\texttt{compute\_impurity\_projections::Bool=false}}
\label{nrg_computeimpurityprojections}
If \texttt{compute\_impurity\_projections==true},
\texttt{nrgfull} computes the thermodynamic weights of the
impurity projections,
\begin{equation}
    P_{\Gamma_i,r_i}(T_N)=\frac{\text{Tr}\{\hat P
    _{\Gamma_i,r_i} e^{-\beta_N \hat H}\}}{\mathcal Z},
\label{eq:impurity_projections}
\end{equation}
where $\mathcal Z$ is the partition function and
$\hat{P}_{\Gamma_i,r_i}$ are operators that project the
impurity-conduction states $\ket{u}_N$ obtained in the
$N$-th NRG step onto the impurity multiplet $\Gamma_i,r_i$,
\begin{equation}
    \hat P_{\Gamma_i,r_i} = \sum_{\gamma_i}
    \ket{\Gamma_i,\gamma_i,r_i}_\text{imp}
    \hat I _\text{con}
    \bra{\Gamma_i,\gamma_i,r_i}_\text{imp},
\label{eq:impurity_projection_operator}
\end{equation}
where $\ket{\Gamma_i,r_i,r_i}_\text{imp}$ are impurity
eigenstates belonging to the impurity multiplet
$\Gamma_i,r_i$ and $\hat I_\text{con}$ is the identity
operator of the conduction electron subspace. They are
computed in the same way as other thermodynamic quantities
(see \ref{nrg_calculation} and Ref. \cite{bulla2008}). 
\par
The results are stored in 
\begin{verbatim}
    impurityprojections/imp_proj_<label>_z<z>.dat
\end{verbatim}
The directory \texttt{impurityprojections} is automatically
created if it does not exist already. The first column of
the file contains the NRG iteration, the second column
contains the temperature, and subsequent columns contain
$P_{\Gamma_i,r_i}(T_N)$ for the impurity multiplets
$\Gamma_i,r_i$ (information in the header of the file). 
\par
The information provided by $P_{\Gamma_i,r_i}$ is useful in
itself in order to obtain information about the impurity
state at all temperatures, but it can also be used to
compute the thermodynamic function of an impurity operator 
that only depends on the impurity multiplet: if $\hat
X=X(\Gamma_i,r_i) \hat{P}_{\Gamma_i,r_i}$ is the operator,
then
\begin{equation}
    X(T_N) 
    = 
    \frac{
        \text{Tr}
        \{\hat X e^{-\beta_N\hat H}\}
    }{
        \mathcal Z
    }
    =
    \sum_{\Gamma_i,r_i}
    X(\Gamma_i,r_i)
    P_{\Gamma_i,r_i}.
\end{equation}
This is not implemented in \texttt{PointGroupNRG}, so it is
left to to the user as a postprocessing step.

\subsubsection{\texttt{half\_band\_width::Float64=1.0}}
\label{nrg_bandwidth}
Half band-width $D$ used in the NRG calculation (see
Ref. \cite{krishna-murthy1980a}).

\subsubsection{\texttt{print\_spectrum\_levels::Int64=0}}
If \texttt{print\_spectrum\_levels!==0}, the lowest $M$
multiplet eigenenergies are printed after each NRG step,
where $M$ is the value of \texttt{print\_spectrum\_levels}.
\end{document}
